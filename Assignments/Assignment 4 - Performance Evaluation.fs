[![Binder](img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath=assignment-performance-evaluation.ipynb)&emsp;
[![Script](img/badge-script.svg)](/Teaching//assignment-performance-evaluation.fsx)&emsp;
[![Notebook](img/badge-notebook.svg)](/Teaching//assignment-performance-evaluation.ipynb)

Student Name | Student Number

**1** | &#32; | &#32; Francisco Perestrello

**2** | &#32; | &#32; 39001


**Signal Name: Highest 5 Days of Return**

**Signal Code: rmax5_21d**

This is an assignment. You may work in pairs (two students) using either student's signal to answer the below questions.  You will find sections labeled **Task** asking you to do each piece of analysis. Please make sure that you complete all of these tasks. Make use of the course resources and example code on the course website. It should be possible to complete all the requested tasks using information given below or somewhere on the course website.


#r "nuget:FSharp.Data"
#r "nuget: FSharp.Stats"
#r "nuget: Plotly.NET, 2.0.0-preview.17"

#r "nuget: Plotly.NET.Interactive, 2.0.0-preview.17"

open System
open FSharp.Data
open Plotly.NET
open FSharp.Stats

// Set dotnet interactive formatter to plaintext
Formatter.Register(fun (x:obj) (writer: TextWriter) -> fprintfn writer "%120A" x )
Formatter.SetPreferredMimeTypesFor(typeof<obj>, "text/plain")
// Make plotly graphs work with interactive plaintext formatter
Formatter.SetPreferredMimeTypesFor(typeof<GenericChart.GenericChart>,"text/html")

## Load Data

First, make sure that you're referencing the correct files.

Here I'm assuming that you have a class folder with this
notebook and these files in it. The folder hierarchy would
look like below where you have the below files and folders accessible.

* `Common.fsx` is on the course website.

* `notebook.ipynb` is this notebook.

* `myExcessReturnPortfolios.csv` is generated by code for construction [signal portfolios](signal-portfolio.html).

```code
/class
    Common.fsx
    notebook.ipynb                
    /data
        myExcessReturnPortfolios.csv
```

let [<Literal>] ResolutionFolder = __SOURCE_DIRECTORY__
Environment.CurrentDirectory <- ResolutionFolder

#load "Common.fsx"
open Common

We get the Fama-French 3-Factor asset pricing model data.


let ff3 = French.getFF3 Frequency.Monthly

### Data file


let [<Literal>] myExcessReturnPortfoliosPath = "data/myExcessReturnPortfolios.csv"

If my paths are correct, then this code should read the first few lines of the files.
If it doesn't show the first few lines, fix the above file paths.


IO.File.ReadLines(myExcessReturnPortfoliosPath) |> Seq.truncate 5

Ok, now assuming those paths were correct the below code will work.
I will put all this prep code in one block so that it is easy to run.


let myExcessReturnPortfolios = 
    CsvProvider<myExcessReturnPortfoliosPath,
                ResolutionFolder = ResolutionFolder>.GetSample()

Headers


myExcessReturnPortfolios.Headers

First few rows


myExcessReturnPortfolios.Rows
|> Seq.take 3

Isolate some notable portfolios.


type SignalPortfolioObs = 
    { Month: DateTime
      Name: string
      Return: float }
let long =
    myExcessReturnPortfolios.Rows
    |> Seq.toList
    |> List.filter (fun row -> row.Index = Some 3)
    |> List.map (fun row -> 
        { Month = row.YearMonth
          Name = "Long"
          Return = row.Ret })

let short =
    myExcessReturnPortfolios.Rows
    |> Seq.toList
    |> List.filter (fun row -> row.Index = Some 1)
    |> List.map (fun row -> 
        { Month = row.YearMonth
          Name = "Short"
          Return = row.Ret })

let shortByMonth = 
    short 
    |> List.map (fun x -> x.Month, x) 
    |> Map

let longShort =
    [ for l in long do 
        // I'm indexing into shortByMonth directly
        // rather than using Map.tryFind because
        // I am pretty confident that the short 
        // data will be there
        let s = shortByMonth[l.Month]
        { Month = l.Month
          Name = "Long-short"
          Return = l.Return - s.Return }]

## Start of assignment

> **Task:** Calculate the annualized Sharpe ratios of your long, short, and long-short portfolios.
> 


let annualizedSharpe (xs: float seq) = 
    ((Seq.mean xs) / (Seq.stDev xs)) * sqrt(12.0)

let longSharpe = long |> List.map (fun x -> x.Return) |> annualizedSharpe
let shortSharpe = short |> List.map (fun x -> x.Return) |> annualizedSharpe
let longShortSharpe = longShort |> List.map (fun x -> x.Return) |> annualizedSharpe
> **Task:** Estimate CAPM and Fama-French 3-factor models for your long-short portfolio.
> 


// Merge portfolio return into our factor model data

type RegData =
    { Date : DateTime
      Portfolio : float
      MktRf : float 
      Hml : float 
      Smb : float }

let ff3ByMonth = 
    ff3
    |> Array.map(fun x -> DateTime(x.Date.Year, x.Date.Month,1), x)
    |> Map

let regData =
    longShort
    |> List.map(fun x ->
        let monthToFind = DateTime(x.Month.Year,x.Month.Month,1)
        match Map.tryFind monthToFind ff3ByMonth with
        | None -> failwith "probably you messed up your days of months"
        | Some ff3 -> 
            { Date = monthToFind
              Portfolio = x.Return - ff3.Rf
              MktRf = ff3.MktRf 
              Hml = ff3.Hml 
              Smb = ff3.Smb })
    |> List.toArray


// Machine learning library

#r "nuget: Accord"
#r "nuget: Accord.Statistics"

open Accord
open Accord.Statistics.Models.Regression.Linear


// Create a model and get model data

type RegressionOutput =
    { Model : MultipleLinearRegression 
      TValuesWeights : float array
      TValuesIntercept : float 
      R2: float }
 
type XY = (float array) array * float array

let fitModel (x: (float array) array, y: float array) =
    let ols = new OrdinaryLeastSquares(UseIntercept=true)
    let estimate = ols.Learn(x,y)
    let mse = estimate.GetStandardError(x,y)
    let se = estimate.GetStandardErrors(mse, ols.GetInformationMatrix())
    let tvaluesWeights = 
        estimate.Weights
        |> Array.mapi(fun i w -> w / se.[i])
    let tvalueIntercept = estimate.Intercept / (se |> Array.last)
    let r2 = estimate.CoefficientOfDetermination(x,y)
    { Model = estimate
      TValuesWeights = tvaluesWeights
      TValuesIntercept = tvalueIntercept  
      R2 = r2 }

let capmModelData = 
    regData
    |> Array.map(fun obs -> [|obs.MktRf|], obs.Portfolio)
    |> Array.unzip 

let ff3ModelData = 
    regData
    |> Array.map(fun obs -> [|obs.MktRf; obs.Hml; obs.Smb |], obs.Portfolio)
    |> Array.unzip
let capmEstimate = capmModelData |> fitModel
let ff3Estimate = ff3ModelData |> fitModel
### CAPM model evaluation.

> **Task:** What is the CAPM alpha for your long-short portfolio. Is it significantly different from zero?
> 


let longShortCapmAlpha = capmEstimate.Model.Intercept
let tValuesCapmAlpha = capmEstimate.TValuesIntercept
longShortCapmAlpha, tValuesCapmAlpha

// As can be seen, the tvalue of the alpha of my long-short portfolio for the CAPM is around -3.20. This value falls onto the rejection zone for a confidence level of 95% on a normal distribution (it is smaller than -1.96), and thus the CAPM alpha is significantly different from zero.
> **Task:** What is the CAPM beta for your long-short portfolio. Is it significantly different from zero?
> 


let longShortCapmBeta = capmEstimate.Model.Coefficients
let tValuesCapmBeta = capmEstimate.TValuesWeights
longShortCapmBeta, tValuesCapmBeta

// As can be seen, the tvalue of the beta of my long-short portfolio for the CAPM is around 12.25. This value also falls onto the rejection zone for a confidence level of 95% on a normal distribution (it is greater than 1.96), and thus the CAPM beta is significantly different from zero.
> **Task:** What is the information ratio for your long-short portfolio when using the CAPM model?
> 


// Get predicted values and residuals

type Prediction = { Label : float; Score : float}

let makePredictions 
    (estimate:MultipleLinearRegression) 
    (x: (float array) array, y: float array) =
    (estimate.Transform(x), y)
    ||> Array.zip
    |> Array.map(fun (score, label) -> { Score = score; Label = label })

let residuals (xs: Prediction array) = xs |> Array.map(fun x -> x.Label - x.Score)

let capmPredictions = makePredictions capmEstimate.Model capmModelData

let capmResiduals = residuals capmPredictions


// Information Ratio Function

let informationRatio monthlyAlpha (monthlyResiduals: float array) =
    let annualAlpha = 12.0 * monthlyAlpha
    let annualStDev = sqrt(12.0) * (Seq.stDev monthlyResiduals)
    annualAlpha / annualStDev 

informationRatio longShortCapmAlpha capmResiduals
### Fama-French 3-factor model evaluation.

> **Task:** What is the Fama-French 3-factor model alpha for your long-short portfolio. Is it significantly different from zero?
> 


let longShortFf3Alpha = ff3Estimate.Model.Intercept
let tValuesFf3Alpha = ff3Estimate.TValuesIntercept
longShortFf3Alpha, tValuesFf3Alpha

// As can be seen, the tvalue of the alpha of my long-short portfolio for the Fama-French 3-Factor Model is around -4.55. This value falls onto the rejection zone for a confidence level of 95% on a normal distribution (it is smaller than -1.96), and thus the Fama-French 3-Factor Model alpha is significantly different from zero.
> **Task:** What are the betas on the Market, HML, and SMB factors for your long-short portfolio. Are they significantly different from zero?
> 


let longShortFf3Betas = ff3Estimate.Model.Coefficients
let tValuesFf3Betas = ff3Estimate.TValuesWeights
longShortFf3Betas, tValuesFf3Betas

// As can be seen, the tvalues of the betas of my long-short portfolio for the Fama-French 3-Factor Model are around 12.67, -7.60, and 10.70. These values all falls onto the rejection zones for a confidence level of 95% on a normal distribution (they are all smaller/greater than -1.96/1.96), and thus the Fama-French 3-Factor Model betas are all significantly different from zero.

> **Task:** Based on the Market, HML, and SMB factor betas for your long-short portfolio, would you say your portfolio is more like a value portfolio, more like a growth portfolio, or neither?
> 


longShortFf3Betas

// To assess whether my portfolio is more like a value portfolio or a growth portfolio, we must look at the beta for the HML (High-Minus-Low) regressor. The HML regressor represents the spread in returns between companies with a high book-to-market value ratio and companies with a low book-to-market value ratio. The negative coefficient means that as this spread increases, the returns on my long-short portfolio decrease. Thus, this portfolio can be said to be more like a growth portfolio.

> **Task:** Based on the Market, HML, and SMB factor betas for your long-short portfolio, would you say your portfolio is more like a small-cap portfolio, more like a large-cap portfolio, or neither?
> 


longShortFf3Betas

// To assess whether my portfolio is more like a small-cap portfolio or a large-cap portfolio, we must look at the beta for the SMB (Small-Minus-Big) regressor. The SMB regressor measures the historic excess returns of small-cap companies over big-cap companies. The positive coefficient means that as these excess returns increase, the returns on my long-short portfolio also increase. Thus, this portfolio can be said to be more like a small-cap portfolio.

> **Task:** What is the information ratio for your long-short portfolio when using the Fama and French 3-factor model?
> 


let ff3Predictions = makePredictions ff3Estimate.Model ff3ModelData
let ff3Residuals = residuals ff3Predictions

informationRatio longShortFf3Alpha ff3Residuals
